# ALL MY PACKAGES ####
## Visualization ####
# library(ggplot2)
library(ggcorrplot)
library(gridExtra)
library(plotly)
library(gt)
library(gtExtras)
library(ggthemes)
library(scales)   # label_percent
library(DT)
library(tidyverse)

## Finance ####
library(quantmod)
library(reshape2)  # melt
library(tidyr)     # pivot
library(magrittr)  # setcolumns
library(knitr)
library(formatR)   # code links in quarto 

## Statistical Analysis and Machine Learning ####
library(PerformanceAnalytics, warn.conflicts = F)
library(sde, warn.conflicts = F)
library(forecast, warn.conflicts = F)
library(caret, warn.conflicts = F)
library(glmnet, warn.conflicts = F)
library(randomForest, warn.conflicts = F)
library(e1071, warn.conflicts = F)

## Financial Modeling and Analysis ####
library(fPortfolio, warn.conflicts = F)
library(tseries, warn.conflicts = F)
library(rugarch, warn.conflicts = F)
library(RQuantLib, warn.conflicts = F)
library(FinancialInstrument, warn.conflicts = F)
library(timeSeries, warn.conflicts = F)
library(PortfolioAnalytics, warn.conflicts = F)
library(NMOF, warn.conflicts = F)
library(sde, warn.conflicts = F)


# FORMULAS ####
RSS <- function(y, y_pred) {
  sum((y - y_pred)^2)
}

R2 <- function(y, y_pred) {
  ssr <- sum((y - y_pred)^2)    # Calculate the sum of squared residuals
  sst <- sum((y - mean(y))^2)   # Calculate the total sum of squares
  
  r_squared <- 1 - (ssr / sst)  # Calculate R-squared
  return(r_squared)
}

ADJR2 <- function(y, y_pred, k) {
  r_squared <- R2(y, y_pred)
  
  n <- length(y)  # number of observations
  adj_r_squared <- 1-((1-r_squared)/(n-k-1))*(n-1)
  
  return(adj_r_squared)
}


Sdate <- function(day, month, year, hour = 0, minute = 0, second = 0) {
  ## helper element to get the date in an Excel like syntax
  # Create the date-time string in "yyyy-mm-dd HH:MM:SS" format
  datetime_string <- sprintf("%04d-%02d-%02d %02d:%02d:%02d", 
                             year, month, day, hour, minute, second)
  
  # Convert to POSIXct object
  datetime <- as.POSIXct(datetime_string, format = "%Y-%m-%d %H:%M:%S", tz = "UTC")
  
  return(datetime)
}

Qdate <- function(day, month, year) {
  ## helper element to get the date in an Excel like syntax ONLY UP TO THE DAY 
  ## helps if you want to sum a day and not a minute
  # Create the date as "yyyy-mm-dd" format
  date_string <- paste(year, month, day, sep = "-")
  
  # Convert to Date object
  date <- as.Date(date_string, format = "%Y-%m-%d")
  
  return(date)
}

## functions and packages used for your quarto document ####
## This document is set up so that it loads a lot of packages at once, 
## so if I want to make it a standalone shareable document i may need to get them and import them manually
## put into a nice dataframe to show in quarto 

isrendering <- function() {
  ## Shorthand to see if the file is rendering in any capacity with a variety of packages 
  doc_fmt <- knitr::opts_knit$get("rmarkdown.pandoc.to")
  
  # Check if rendering to known document formats
  return(
    knitr::is_latex_output() || 
      knitr::is_html_output() || 
      is.null(doc_fmt %in% c("html", "docx", "pdf", "pptx", "epub", "markdown", "gfm", "odt", "beamer"))
  )
}

if_rendering <- function(yes, no) {
  ## Same idea as isrendering but directly in an ifelse to not have certain things run all the time if you are running the document
  ## like the dependencies here below
  
  doc_fmt <- knitr::opts_knit$get("rmarkdown.pandoc.to")
  
  # Check if rendering to known document formats
  render_status <- c(
    knitr::is_latex_output() || 
      knitr::is_html_output() || 
      is.null(doc_fmt %in% c("docx", "pdf", "pptx", "epub", "markdown", "gfm", "odt", "beamer"))
  )
  
  # Return yes or no based on rendering status
  ifelse(render_status, yes, no)
}

when_rendering <- function(action) {
  ## when_rendering: Returns the 'action' (e.g., a data frame) if the document is rendering;
  ## otherwise returns the message "document is not rendering".
  
  doc_fmt <- knitr::opts_knit$get("rmarkdown.pandoc.to")
  
  # Determine if rendering is happening based on known formats
  render_status <- knitr::is_latex_output() || 
    knitr::is_html_output() ||
    (!is.null(doc_fmt) && doc_fmt %in% c("docx", "pdf", "pptx", "epub", 
                                         "markdown", "gfm", "odt", "beamer"))
  
  if (render_status) {
    return(action)
  } else {
    return("document is not rendering")
  }
}

packages_loaded <- function(file, include_main = TRUE, dataframe = TRUE) {
  if (include_main) {
    file <- c(file, "C:/Users/pietr/OneDrive/Desktop/formula.main.R")
  }
  
  # Extract dependencies
  dep <- unique(sort(renv::dependencies(file, progress = FALSE)$Package))
  
  # Remove renv since this is the only use for it 
  dep <- setdiff(x = dep, "renv")

  if (dataframe) { 
    # Split into 3 roughly equal columns
    n <- length(dep)
    ndep <- ceiling(n / 3)
    
    # Fill missing spots with NA to match lengths
    dep <- c(dep, rep(" ", (ndep * 3) - n))
    
    # Create a matrix to make the dataframe into 3 columns going down the alphabet row by row and not column-wise
    # matrix(1:9, nrow = 3, ncol = 3, byrow = TRUE)
    mat <- matrix(1:length(dep), ncol = 3, byrow = TRUE)
    
    col1 <- dep[mat[,1]]
    col2 <- dep[mat[,2]]
    col3 <- dep[mat[,3]]
    
    # Create data frame
    final_df <- data.frame(
      "Packages.1" = col1,
      "Packages.2" = col2,
      "Packages.3" = col3
    )
    return(final_df)
  } else {
    return(dep)
  }
}

functions_loaded <- function(file, dataframe = TRUE) {
  ## functions_loaded: Retrieves functions loaded from the main custom file
  ## and returns only those functions that are used in the target script.
  
  # Create a separate environment to hold functions from the main file
  mainEnv <- new.env()
  
  # Source the custom functions file into the mainEnv environment
  source_path <- "C:/Users/pietr/OneDrive/Desktop/formula.main.R"
  source(source_path, local = mainEnv)
  
  # Get all functions defined in the mainEnv
  custom_functions <- ls(envir = mainEnv)
  custom_functions <- custom_functions[sapply(custom_functions, 
                                              function(x) is.function(get(x, envir = mainEnv)))]
  
  # Read the target script file
  script_content <- readLines(file)
  
  # Extract all words from the script that could be function calls
  script_words <- unlist(strsplit(script_content, "\\W+"))
  
  # Identify which of the main file functions are actually used in the target script
  used_functions <- intersect(custom_functions, script_words)
  
  # Exclude the dependency-checking functions from the result
  used_functions <- setdiff(used_functions, c("functions_loaded", "packages_loaded", 
                                              "required_functions", "required_packages"))
  
  if (length(used_functions) == 0) {
    return(cat("There are no functions coming from the main file", "\n"))
  }
  
  if (dataframe) {
    # Split into 3 roughly equal columns
    n <- length(used_functions)
    ndep <- ceiling(n / 3)
    
    # Fill missing spots with NA (or a blank string) to match lengths
    used_functions <- c(used_functions, rep(" ", (ndep * 3) - n))
    
    # Create a matrix to form 3 columns (row-wise filling)
    mat <- matrix(1:length(used_functions), ncol = 3, byrow = TRUE)
    
    col1 <- used_functions[mat[,1]]
    col2 <- used_functions[mat[,2]]
    col3 <- used_functions[mat[,3]]
    
    # Create and return the data frame
    final_df <- data.frame(
      "Functions.1" = col1,
      "Functions.2" = col2,
      "Functions.3" = col3
    )
    return(final_df)
  } else {
    return(used_functions)
  }
}

required_packages <- function(file, dataframe = TRUE) {
  ## What are the packages actually getting called in this document?
  
  # Get all lines from the script
  script_lines <- readLines(file)
  
  # Find all things that have "library\\(" or "require\\(" and remove the rest from the start
  loaded_packages <- unique(gsub(".*\\((\\w+).*", "\\1", 
                                 grep("library\\(|require\\(", script_lines, value = TRUE)))
  
  # Get all functions from the code part "return(" and remove the parentesis
  all_functions <- unlist(regmatches(script_lines, gregexpr("\\b\\w+\\(", script_lines)))
  all_functions <- unique(gsub("\\(", "", all_functions))
  
  # find all packages 
  package_info <- lapply(all_functions, function(funct) {
    if (exists(funct, mode = "function")) {
      find(funct)
    } else {
      NA
    }
  })
  
  # get package names
  inferred_packages <- gsub("package:", "", unlist(package_info))
  inferred_packages <- unique(inferred_packages[!is.na(inferred_packages)])
  
  # remove the base R packages
  final_packages <- sort(unique(c(loaded_packages, inferred_packages)))
  final_packages <- setdiff(final_packages, c(".GlobalEnv", "base", "stats", "graphics", 
                                              "grDevices", "utils", "utils", "datasets",
                                              "Matrix", "methods", "tools"))
  
  
  if (dataframe) {
    # Split into 3 roughly equal columns
    n <- length(final_packages)
    ndep <- ceiling(n / 3)
    
    # Fill missing spots with NA to match lengths
    final_packages <- c(final_packages, rep(" ", (ndep * 3) - n))
    
    # Create a matrix to make the dataframe into 3 columns going down the alphabet row by row and not column-wise
    # matrix(1:9, nrow = 3, ncol = 3, byrow = TRUE)
    mat <- matrix(1:length(final_packages), ncol = 3, byrow = TRUE)
    
    col1 <- final_packages[mat[,1]]
    col2 <- final_packages[mat[,2]]
    col3 <- final_packages[mat[,3]]
    
    # Create data frame
    final_df <- data.frame(
      "Required.Packages.1" = col1,
      "Required.Packages.2" = col2,
      "Required.Packages.3" = col3
    )
    return(final_df)
  } else {
    return(final_packages)
  }
}

required_functions <- function(file, dataframe = TRUE) {
  ## What are the functions that are user-defined in this document?
  # Read the script
  script_lines <- readLines(file)
  
  # Find lines that contain "function"
  function_lines <- grep("<-\\s*function\\(", script_lines, value = TRUE)
  
  # Extract the function names (before the "<-")
  defined_functions <- gsub("\\s*<-\\s*function\\(.*", "", function_lines)
  
  # Trim whitespace
  defined_functions <- trimws(defined_functions)
  
  defined_functions <- setdiff(x = defined_functions, c("packages_loaded", "required_functions", "required_packages"))
  
  if (length(defined_functions) == 0) {
    return(cat("There are no user-defined functions in the script.", "\n"))
    }
  
  if (dataframe) {
    # Split into 3 roughly equal columns
    n <- length(defined_functions)
    ndep <- ceiling(n / 3)
    
    # Fill missing spots with NA to match lengths
    defined_functions <- c(defined_functions, rep(" ", (ndep * 3) - n))
    
    # Create a matrix to make the dataframe into 3 columns going down the alphabet row by row and not column-wise
    # matrix(1:9, nrow = 3, ncol = 3, byrow = TRUE)
    mat <- matrix(1:length(defined_functions), ncol = 3, byrow = TRUE)
    
    col1 <- defined_functions[mat[,1]]
    col2 <- defined_functions[mat[,2]]
    col3 <- defined_functions[mat[,3]]
    
    # Create data frame
    final_df <- data.frame(
      "Required.Functions.1" = col1,
      "Required.Functions.2" = col2,
      "Required.Functions.3" = col3
    )
    return(final_df)
  } else {
    return(defined_functions)
  }
}

## Data Visualization ####
quickplot <- function(data, title = NULL, plot_engine = c("ggplot", "plotly"), xlab="Date", ylab="Value",
                      show_legend = TRUE, subtitle = NULL, caption = NULL, linewidth = 0.4, 
                      legend_name = "Variable", legend_position = c("right", "left", "bottom", "top"), alpha = 1, 
                      type = geom_line, facet_wrap = FALSE, x_size = 1, x_start = 1) {
  
  ## my pride and joy, turning a dataframe vector or matrix into a ggplot element
  ## Works better with xts and ts dataframes due to having index being the date instead of a number 1:n  
  
  # Convert the data to a data frame and add the Date column 
  plot_data <- data.frame(Date = index(data), data)
  
  ## Define a custom color palette (14 colors *1000 repetitions = 14000, hopefully its enough)
  custom_palette <- rep(c("firebrick","darkblue","#006400","gray30","#457575","#6100a8","orange2","brown",
                          "#483D8B","#556B2F","#8B008B","#5F9EA0","#6B8E23","#9932CC"), 1000) 
  ## When doing things like Montecarlo simulation of random walks increase this number
  
  # Reshape the data to long format (this allows the lines to be colored different one from the other)
  my_data_long <- pivot_longer(data = plot_data,
                               cols = -Date,
                               names_to = "Variable",
                               values_to = "Value")
  
  if (class(data)[1]!="xts") {
    my_data_long$Date <- my_data_long$Date/x_size
  }
  
  if (x_start != 1) {
    my_data_long$Date <- my_data_long$Date + x_start
  }
  

  # Create the ggplot object
  plot <- ggplot(my_data_long, 
                 aes(x = Date, y = Value, color = Variable)) +
    type(linewidth = linewidth, alpha = alpha) +
    labs(title = title,
         subtitle = subtitle,
         caption = caption,
         x=xlab,
         y=ylab) +
    scale_color_manual(name = legend_name, values = custom_palette)+
    theme(legend.position = legend_position[1], plot.title = element_text(hjust = 0.5), plot.subtitle =  element_text(hjust = 0.5))
  
  # Conditionally show the legend
  ## Sometimes its not necessary like with only 1 series or when the names are just not necessary
  if (!show_legend) {
    plot <- plot + theme(legend.position = "none")
  }
  
  ## make each line on its own square
  if (facet_wrap) {
    plot <- plot + facet_wrap(~Variable)
    return(plot)
  }
  
  # Return the final plot, either as a ggplot or plotly object
  final_plot <- switch(plot_engine[1],
                       "ggplot" = plot,
                       "plotly" = ggplotly(plot) %>%
                         layout(xaxis = list(rangeslider = list(visible = TRUE, thickness = 0.08)),
                                yaxis = list(fixedrange = FALSE), dragmode = "zoom")
                       )
  
  return(final_plot)
}

shade_signals <- function(Signal, Date) {
  ## a function to get the entry and exit times to then use into the geom_rect
##   geom_rect(data = shading, aes(xmin = Start, xmax = End, ymin = min(df$Price),
##   ymax = ymax = min(df$Price) + (max(df$Price) - min(df$Price)) / 4),
##   fill = "blue", alpha = 0.2, inherit.aes = FALSE) +
  
  ## or use -Inf and Inf
  # Identify entry and exit points
  df <- data.frame(Date = Date, Signal = na.fill(Signal, 0))
  df <- df %>%
    mutate(ShiftedSignal = dplyr::lag(Signal, default = 0)) %>%  # Shift signal to find transitions
    mutate(Change = (Signal != ShiftedSignal))                   # Detect changes
  
  # Create a table of entry and exit points
  entries <- df %>%
    dplyr::filter(Change & Signal == 1) %>%
    dplyr::select(Start = Date)
  
  exits <- df %>%
    dplyr::filter(Change & Signal == 0) %>%
    dplyr::select(End = Date)
  
  # Ensure we have matching start/end pairs
  if (nrow(entries) > nrow(exits)) {
    exits <- rbind(exits, data.frame(End = tail(df$Date, 1)))    # Assume last date as exit if missing
  }
  
  shading <- cbind(entries, exits)                               # Combine start & end
  return(shading)
}  


gg_qq_plot <- function(data, title = NA) {
  realtitle <- ifelse(is.na(title), yes = "QQ Plot", no = paste("QQ Plot of", title)) 
    
  # Compute theoretical quantiles and sample quantiles
  df <- data.frame(
    sample = sort(data),
    theoretical = qnorm(ppoints(length(data)))
  )
  
  # Compute line of best fit (for reference line)
  fit <- lm(sample ~ theoretical, data = df)
  
  # Generate QQ plot with ggplot2
  ggplot(df, aes(x = theoretical, y = sample)) +
    geom_hline(yintercept = 0, color = "black", linetype = "dotted", linewidth = 0.2)+
    geom_vline(xintercept = 0, color = "black", linetype = "dotted", linewidth = 0.2)+
    geom_point(color = "blue", size = 2) +  # QQ points
    geom_abline(intercept = coef(fit)[1], slope = coef(fit)[2], color = "red", linewidth=1) +  # Reference line
    labs(title = realtitle, x = "Theoretical Quantiles", y = "Sample Quantiles") +
    theme_minimal()
}


show_df <- function(prices, n = 5, rounding = Inf, name_first_col = "DATE") {
  ## Shorthand for when you have to visualize data showing first and last lines of the dataframe with a line in the middle
  ## not only useful for stocks but also for other dataframes by changing the name of the first column
  
  price_date <- cbind(index(prices), smart_round(data.frame(prices), rounding)) # get index / time column here
  colnames(price_date) <- (c(name_first_col, colnames(prices)))
  rownames(price_date) <- (1:length(index(prices)))
  
  # The whole point of this 
  first_rows <- head(price_date, n)
  last_rows <- tail(price_date, n)
  
  # Create a separator row with NA, having it be directly ... would be better but to use bind rows you need the same datatype
  separator <- matrix(NA, nrow = 1, ncol = ncol(price_date))
  colnames(separator) <- (c(name_first_col, colnames(prices)))
  
  # Combine with separator row ALL NAMES SHOULD BE THE SAME
  summary_table <- bind_rows(first_rows, as.data.frame(separator), last_rows)
  
  return(summary_table)
}

format_number <- function(x, digits = 4) {
  ## better print of numbers in things like gt or ggplots
  # Leave 0 and 1 unchanged
  if (x == 0 || x == 1) {
    return(x)
    # make numbers that are lower than 0.0001 to appear in scientific format, otherwise leave as is
  } else if (abs(x) < 1e-4 || abs(x) >= 1e+4) {
    return(format(x, scientific = TRUE, digits = digits))
  } else {
    # Round to 4 decimal places for other numbers
    return(format(round(x, 4), nsmall = 4))
  }
}

format_dataframe <- function(df, digits = 4) {
  # Function to apply format_number, to an entire dataframe, only formatting numeric columns
  df[] <- lapply(df, function(col) {
    if (is.numeric(col)) {
      return(sapply(col, format_number, digits = digits))
    } else {
      return(col)  # Leave non-numeric columns as they are
    }
  })
  return(df)
}

approx_fraction <- function(decimal, digits = 2) {
  ## iterative approach on finding the best approximation for a decimal number
  ## you get the actual numerator and denominator, approx_value, difference with real one, and iterations
  format_number <- function(x, Fdigits = 4) {
    if (x == 0 || x == 1) {
      return(x)
    } else if (abs(x) < 1e-4 || abs(x) >= 1e+4) {
      return(format(x, scientific = TRUE, digits = Fdigits))
    } else {
      return(format(floor(x), nsmall = 0))    # <- HERE 
    }
  }
  
  numerator1 <- 0
  denominator1 <- 1
  numerator2 <- 1
  denominator2 <- 0
  temp_decimal <- decimal
  iteration <- 0
  max_denom <- 10 ** digits 
  
  while (TRUE) {   # Continued fraction expansion
    integer_part <- floor(temp_decimal)   # Get the integer part
    
    # Update the numerator and denominator
    # New numerator and denominator are the base integer part scaled by the current fraction
    new_numerator <- integer_part * numerator2 + numerator1
    new_denominator <- integer_part * denominator2 + denominator1
    
    # If the denominator exceeds max_denom then this is the best approximation of the fraction
    if (new_denominator > max_denom) break
    
    # Otherwise keep going Update for next iteration
    numerator1 <- numerator2
    denominator1 <- denominator2
    numerator2 <- new_numerator
    denominator2 <- new_denominator
    
    # Update the decimal part
    temp_decimal <- 1 / (temp_decimal - integer_part)
    
    # Keep the count of how many iterations 
    iteration <- iteration+1
  }
  
  # Show bits
  approx_value <- numerator2 / denominator2
  difference <- decimal - approx_value
  
  df <- data.frame(fraction = paste(format_number(numerator2), "/", format_number(denominator2)), 
                   difference = format_number(difference),
                   approximate = approx_value,
                   iterations = iteration
  )
  rownames(df) <- ""
  
  return(df)
}

desc_df <- function(data, quantiles = c(0.01, 0.25, 0.75, 0.99), digits = 4) {
  ## describe has a function for this but i don't want to import a whole package for this
  
  # Define the function to calculate summary statistics for each column
  summary_stats <- function(x) {
    n                 <- sum(!is.na(x))
    mean              <- mean(x, na.rm = TRUE)
    sd                <- sd(x, na.rm = TRUE)
    median            <- median(x, na.rm = TRUE)
    trimmed           <- mean(x, trim = 0.1, na.rm = TRUE)
    min               <- min(x, na.rm = TRUE)
    max               <- max(x, na.rm = TRUE)
    range             <- max - min
    skew              <- sum((x - mean) ^ 3, na.rm = TRUE) / (n * sd ^ 3)
    kurtosis          <- sum((x - mean) ^ 4, na.rm = TRUE) / (n * sd ^ 4) - 3
    se                <- sd / sqrt(n)
    percent_missing   <- sum(is.na(x)) / length(x) * 100
    quantiles_values  <- quantile(x, probs = quantiles, na.rm = TRUE)
    
    # Return the calculated statistics as a named vector
    c(
      n = n,
      mean = mean,
      sd = sd,
      median = median,
      trimmed = trimmed,
      min = min,
      max = max,
      range = range,
      skew = skew,
      kurtosis = kurtosis,
      se = se,
      '%NA' = percent_missing,
      Q = quantiles_values[1],
      Q = quantiles_values[2],
      Q = quantiles_values[3],
      Q = quantiles_values[4]
    )
  }
  
  # Apply the function to each column in the dataset
  stats <- sapply(data, function(col) {
    if (is.numeric(col))
      summary_stats(col)
    else
      rep(NA, length(summary_stats(0)))
  })
  
  # Transpose and convert to data frame for readability
  as.data.frame(round(t(stats), digits = digits))
}

check_acc <- function(data1, data2, n = 10, title = NULL, visual = c(TRUE, FALSE, "both")) {
  
  ## checking percentage of same values as the rounding decimals increase
  ## the logic is that if the data sets are anything alike (like 2 different models results for the same dataset) 
  ## you should see how far in the rounding are the data sets similar
  
  accuracy <- data.frame()
  
  # rounding df
  for (i in 0:n) {
    new <- mean(round(data1, i) == round(data2, i), na.rm= TRUE)
    accuracy <- rbind(accuracy, new)
  }
  colnames(accuracy) <- "values"
  
  # showing that decrease in a ggplot
  accplot <- ggplot(accuracy, aes(x = 0:n, y = values)) +
    geom_line(linewidth = 1, color = "dodgerblue2") +
    geom_point(size = 2, color = "dodgerblue3") +
    scale_x_continuous(breaks = seq(0, n, by = 1))+
    ylim(0,1)+
    scale_y_continuous(labels = label_percent(), limits = c(0, 1)) +
    labs(title = "Percentage of accuracy", y = NULL, x = "Rounding decimals")
  
  plot <- 
    data.frame(data1 = data1, data2 = data2) %>% 
    head(5000) %>%
    ggplot(aes(x = index(data1)))+
    geom_point(aes(y = data1, color = "Data1"), size = 2) +
    geom_point(aes(y = data2, color = "Data2"), size = 2) +
    scale_color_manual(values = c(Data1 = "purple3", Data2 = "mediumseagreen"), name = NULL) +
    labs(title = "Visual inspection", y = NULL, x = NULL)+
    theme(legend.position = "bottom")
  

  # summaries of both dataframes
  sum_df <- summary(data.frame("data1" = data1, "data2" = data2))

  # seeing all values different from 0 as a %
  full_df <- data.frame(accuracy[accuracy!=0]*100) %>%
    round(2) %>%
    data.frame() %>%
    set_colnames("Values !=0 %")

  # Use grid.arrange to display the plot, summary, and dataframe
  # grids <- grid.arrange(accplot, tableGrob(full_df), ncol = 2, layout_matrix = matrix(c(1,1,2), nrow = 1))
  
  
  # Return results
  if (visual[1] == TRUE) {
    return(marrangeGrob(list(accplot, plot), ncol = 2, nrow = 1, top = title))
  } else if (visual[1] == FALSE) {
    return(list(df = full_df, sum_df = sum_df))
  } else if (visual[1] == "both") {
    return(list(plots = marrangeGrob(list(accplot, plot), ncol = 2, nrow = 1, top = title), 
                df = full_df, sum_df = sum_df))
  } 
  
}

## Volatility & Option Pricing ####
ichimoku <- function(HLC, nFast=9, nMedium=26, nSlow=52) {
  ## ichimoku cloud is a way of creating signals for trading
  
  Close <- Cl(HLC)
  conversionLine <- (runMax(Hi(HLC), nFast) + runMin(Lo(HLC), nFast)) / 2
  baseLine <- (runMax(Hi(HLC), nMedium) + runMin(Lo(HLC), nMedium)) / 2
  leadingSpanA <- (lag(conversionLine, nMedium) + lag(baseLine, nMedium)) / 2
  leadingSpanB <- (runMax(Hi(HLC), nSlow) + runMin(Lo(HLC), nSlow)) / 2
  leadingSpaAVG <- apply(cbind(leadingSpanA, leadingSpanB), 1, mean, na.rm = TRUE)
  laggingSpan <- lag(Cl(HLC), nMedium)
  
  ichimokuCloud <- cbind(Close,
                         conversionLine,
                         baseLine,
                         leadingSpanA,
                         leadingSpanB,
                         leadingSpaAVG,
                         laggingSpan)
  
  colnames(ichimokuCloud) <- c(gsub(pattern = ".Close", replacement = " Stock Price", x = colnames(Close)),
                               "Tenkan-sen",
                               "Kijun-sen",
                               "Senkou Span A",
                               "Senkou Span B",
                               "Senkou Span AVG",
                               "Chikou Span")
  return(ichimokuCloud)
}

estvol <- function(Stock_price) { 
  ## B&S method for estimating volatility from timeseries data Starting from stockprices, 
  ui <- log(Stock_price, lag(Stock_price))
  
  time <- year(index(Stock_price))
  tau <- time[length(time)]-time[1]
  s <- stdev(ui, na.rm = TRUE)
  estvol <- s/sqrt(tau)
  
  return(estvol)
}

basic_vol <- function(Stock_price, tail = 60, trade_days = 252) {
  log_returns <- diff(log(Stock_price))
  
  # Compute annualized historical volatility (e.g., over last 60 days)
  sigma <- sd(tail(log_returns, tail)) * sqrt(trade_days)
  
  return(sigma)
}

forward_price <- function(K, r, Time = 1) {
  K*exp(-r*Time)
}

bond_price <- function(L, c, Tyears, r) {
  coupons_PV <- numeric(Tyears)
  for (t in 1:Tyears) {
    coupons_PV[t] <- c/(1+r)^t
  }
  sum(c(coupons_PV, L/(1+r)^Tyears))
}

IRR <- function(Price, FV, c, Tyears) {
  coupons_PV <- numeric(Tyears)
  for (t in 1:Tyears) {
    coupons_PV[t] <- c/(1+r)^t
  }
  sum(c(coupons_PV, L/(1+r)^Tyears))
}

black_scholes <- function(S = 100, K = 100, Time = 0.5, r = 0.05, sigma = 0.2, q = 0, 
                          type = "call", rounding = Inf) {
  d1 <- (log(S / K) + (r - q + sigma ^ 2 / 2) * Time) / (sigma * sqrt(Time))
  d2 <- d1 - sigma * sqrt(Time)
  
  price <- switch (type,
                   "call" = S * exp(-q * Time) * pnorm(d1) - K * exp(-r * Time) * pnorm(d2),
                   "put" = K * exp(-r * Time) * pnorm(-d2) - S * exp(-q * Time) * pnorm(-d1)
  )
  
  price <- ifelse(test = is.null(price),
                  yes = "ERROR",
                  no = round(price, rounding))
  
  return(price)
}

BS_full <- function(S = 100, K = 100, Time = 0.5, r = 0.05, sigma = 0.2, q = 0, rounding = Inf) {
  ## BS with d1 d2 and the respective normal table values and rounding to actually see if it matches
  
  # Compute d1 and d2 with q included
  d1 <- (log(S / K) + (r - q + sigma ^ 2 / 2) * Time) / (sigma * sqrt(Time))
  d2 <- d1 - sigma * sqrt(Time)
  
  # Compute call and put prices, rounded to the specified number of digits
  price <- round(data.frame(
    "call" = S * exp(-q * Time) * pnorm(d1) - K * exp(-r * Time) * pnorm(d2),
    "put" = K * exp(-r * Time) * pnorm(-d2) - S * exp(-q * Time) * pnorm(-d1)
  ), rounding)
  
  # Compute d1 and d2 statistics, rounded to the specified number of digits
  dd <- round(data.frame(
    "d1" = c(d1, pnorm(d1), pnorm(-d1)),
    "d2" = c(d2, pnorm(d2), pnorm(-d2))
  ), rounding)
  
  # Set row names for clarity
  rownames(dd) <- c("Reg", "call", "put")
  
  # Return a list containing d1/d2 stats and option prices
  price_df <- list(dd, price)
  
  return(price_df)
}

greeks <- function(S=100, K=100, r=0.05, sigma=0.2, Time=1, q = 0, type = "call", rounding = Inf) {
  d1 <- (log(S / K) + (r - q + sigma^2 / 2) * Time) / (sigma * sqrt(Time))
  d2 <- d1 - sigma * sqrt(Time)
  
  # Calculate the Greeks
  delta <- ifelse(type == "call",
                  exp(-q * Time) * pnorm(d1),
                  exp(-q * Time) * (pnorm(d1) - 1)
                  )
  gamma <- exp(-q * Time) * dnorm(d1) / (S * sigma * sqrt(Time))
  theta <- ifelse(type == "call",
                  (-S * dnorm(d1) * sigma * exp(-q * Time) / (2 * sqrt(Time)) - r * K * exp(-r * Time) * pnorm(d2)),
                  (-S * dnorm(d1) * sigma * exp(-q * Time) / (2 * sqrt(Time)) + r * K * exp(-r * Time) * pnorm(-d2)))
  vega <- S * exp(-q * Time) * dnorm(d1) * sqrt(Time)
  rho <- ifelse(type == "call",
                K * Time * exp(-r * Time) * pnorm(d2),
                -K * Time * exp(-r * Time) * pnorm(-d2))
  
  combined <- data.frame(
    "delta" = delta,
    "gamma" = gamma,
    "theta" = theta,
    "vega" = vega,
    "rho" = rho)
  
  return(round(combined, rounding))
}

get_portfolio <- function(tickers_portfolio, start_date = Sys.Date() - 6540, end_date = Sys.Date(), fun = Ad,
                          clean_names = F, na.locf = T) {
  
  ## Helper function to immediately get from the tickers prices or whatever part of the High Low Close Adjusted Volume 
  
  data1 = lapply(tickers_portfolio, FUN = function(x) {
    fun(getSymbols(x, from = start_date, to = end_date, auto.assign = FALSE))
  })
  
  # convert to data frame
  portfolio = do.call(merge, data1)
  
  ## na.locf allows to merge the weekends by taking the interpolation to skip weekends and holidays
  if (na.locf == TRUE) {
    portfolio <- na.locf(portfolio)
  }
  
  ## clean names gets only the stock ticker names
  if (clean_names) {
    colnames(portfolio) <- before_dot(portfolio)
  }
  return(portfolio)
}


## Data Transformation & Cleaning ####
smart_round <- function(df, digits = 2) {
  df %>%
    mutate(across(where(is.numeric), round, digits = digits))
}
delog <- function(log_returns, start = 100) {
  
  # Initialize the index level vector
  index_level <- numeric(length(log_returns))
  # Set the first index level to the start value (100 in the most cases) * e^LR1
  index_level[1] <- start * exp(log_returns[1])
  # Calculate the subsequent index levels
  for (t in 2:length(log_returns)) {
    index_level[t] <- index_level[t - 1] * exp(log_returns[t])
  }
  return(index_level)
}

delog <- function(log_returns, start_value = 100) {
  # Initialize the index level vector
  index_level <- numeric(length(log_returns))
  # Set the first index level to 100 * e^LR1
  index_level[1] <- start_value * exp(log_returns[1])
  # Calculate the subsequent index levels
  for (t in 2:length(log_returns)) {
    index_level[t] <- index_level[t - 1] * exp(log_returns[t])
  }
  return(index_level)
}

rebase <- function(data, start_value = 100, na.fill = 0, round = Inf) {
  data %>% 
    ROC() %>%
    na.fill(fill = 0) %>%
    apply(., 2, delog) %>% 
    round(digits = round) %>%
    as.data.frame()
}

remove_outliers <- function(x, fill=c("mean","median","NA","zero"), min = 0.25, max =0.75) {
  ## Remove outliers that are outside the interquartile Range and replace it with something
  ## Reasoning being that when looking at a stationary data frame the values are outside the interquartile range are outliers
  ## Obviously when looking at an explosive data frame like a stock price it doesnt work
  
  Q1 <- quantile(x, min, na.rm = TRUE)
  Q3 <- quantile(x, max, na.rm = TRUE)
  IQR <- Q3 - Q1
  
  lower_bound <- Q1 - 2 * IQR
  upper_bound <- Q3 + 2 * IQR
  
  
  rep <- switch (fill[1],
                 "mean" = mean(x, na.rm = TRUE),
                 "median" = median(x, na.rm = TRUE),
                 "NA" = NA,
                 "zero" = 0
  )
  
  
  x[x < lower_bound | x > upper_bound] <- rep
  return(x)
}

find_outliers <- function(x, yes=1, no=0) {
  ## Remove outliers that are outside the interquartile Range and replace it with something
  ## Reasoning being that when looking at a stationary data frame the values are outside the interquartile range are outliers
  ## Obviously when looking at an explosive data frame like a stock price it doesn't work
  
  Q1 <- quantile(x, 0.25, na.rm = TRUE)
  Q3 <- quantile(x, 0.75, na.rm = TRUE)
  IQR <- Q3 - Q1
  
  lower_bound <- Q1 - 2 * IQR
  upper_bound <- Q3 + 2 * IQR
  
  df <- numeric(length(x))
  
  df <- data.frame(ifelse(x < lower_bound | x > upper_bound, yes = yes, no = no)) %>% 
    na.fill(fill = 0)
  
  
  return(df)
}

remove_zero <- function(x, fill=c("NA","mean")) {
  
  rep <- switch (fill[1],
                 "mean" = mean(x, na.rm = TRUE),
                 "median" = median(x, na.rm = TRUE),
                 "NA" = NA,
                 "zero" = 0)
  
  # Check if the input is numeric or a data frame
  if (is.numeric(x)) {
    x[x == 0] <- rep
  } else if (is.data.frame(x)) {
    x[] <- lapply(x, function(col) {
      col[col == 0] <- rep
      return(col)
    })
  }
  return(x)
}

normalize <- function(x, peak = 100) {
  MAX <- max(x, na.rm = TRUE)
  
  df <- (x/MAX)*peak
  return(df)
}

clean_and_convert <- function(x, fill = c("zero","mean","median","NA")) {
  
  rep <- switch (fill[1],
                 "mean" = mean(x, na.rm = TRUE),
                 "median" = median(x, na.rm = TRUE),
                 "NA" = NA,
                 "zero" = 0)
  
  if (is.character(x)) {  # Check if the column is of character type
    x <- ifelse(x == "< 1", yes = rep, no = x)  # Replace "< 1" with what you want from the fill argument
  }
  return(x)
}

rotate_clockwise <- function(mat) {
  t(apply(mat, 2, rev)) # rotates clockwise a square matrix, for correlation plots mainly
}

ODD <- function(vec) {
  odd_numbers <- vec[vec %% 2 != 0]
  return(odd_numbers)
}

EVEN <- function(vec) {
  even_numbers <- vec[vec %% 2 == 0]
  return(even_numbers)
}

## Text Formatting ####
before_dot <- function(obj, type= c("dataframe","string")) {
  # takes all text before the "."
  text <- switch(type[1],
                 "string" = obj,
                 "dataframe" = colnames(obj))
  
  sub("\\..*", "", text)
}

before_triple_dot <- function(obj,type= c("dataframe","string")) {
  # takes all text before the "..."
  text <- switch(type[1],
                 "string" = obj,
                 "dataframe" = colnames(obj))
  
  sub("\\.\\.\\..*", "", text)
}

fixnames <- function(name, replacement = " Stock Price") {
  # simpler syntax for gsub, useful when you need a name to go into a graph like with quickgraph by changing the label of a dyseries
  
  gsub(pattern = ".Close", replacement = replacement, x = name)}

remove_caret <- function(input_string) {
  # Use gsub to replace the ^ character with an empty string
  result <- gsub("\\^", "", input_string)
  return(result)
}

# HELPER ELEMENTS #####
custom_palette <- rep(c("firebrick","darkblue","#006400","#457575","#6100a8","orange2","gray30","brown", 
                        "#483D8B", "#556B2F","#8B008B","#5F9EA0", "#6B8E23","#9932CC"), 20)

setDefaults(getSymbols.av, api.key="0ODSCQDPA42QMDDJ") # my api key for alpha vantage

Sys.setlocale("LC_TIME", "English") # set output language in english
theme_set(theme_minimal())
line_width <- 0.4

## All colors ####
{allcolors <- c(
"white",                "aliceblue",            "antiquewhite",         "antiquewhite1",        "antiquewhite2",        
"antiquewhite3",        "antiquewhite4",        "aquamarine",           "aquamarine1",          "aquamarine2",          
"aquamarine3",          "aquamarine4",          "azure",                "azure1",               "azure2",               
"azure3",               "azure4",               "beige",                "bisque",               "bisque1",              
"bisque2",              "bisque3",              "bisque4",              "black",                "blanchedalmond",       
"blue",                 "blue1",                "blue2",                "blue3",                "blue4",                
"blueviolet",           "brown",                "brown1",               "brown2",               "brown3",               
"brown4",               "burlywood",            "burlywood1",           "burlywood2",           "burlywood3",           
"burlywood4",           "cadetblue",            "cadetblue1",           "cadetblue2",           "cadetblue3",           
"cadetblue4",           "chartreuse",           "chartreuse1",          "chartreuse2",          "chartreuse3",          
"chartreuse4",          "chocolate",            "chocolate1",           "chocolate2",           "chocolate3",           
"chocolate4",           "coral",                "coral1",               "coral2",               "coral3",               
"coral4",               "cornflowerblue",       "cornsilk",             "cornsilk1",            "cornsilk2",            
"cornsilk3",            "cornsilk4",            "cyan",                 "cyan1",                "cyan2",                
"cyan3",                "cyan4",                "darkblue",             "darkcyan",             "darkgoldenrod",        
"darkgoldenrod1",       "darkgoldenrod2",       "darkgoldenrod3",       "darkgoldenrod4",       "darkgray",             
"darkgreen",            "darkgrey",             "darkkhaki",            "darkmagenta",          "darkolivegreen",       
"darkolivegreen1",      "darkolivegreen2",      "darkolivegreen3",      "darkolivegreen4",      "darkorange",           
"darkorange1",          "darkorange2",          "darkorange3",          "darkorange4",          "darkorchid",           
"darkorchid1",          "darkorchid2",          "darkorchid3",          "darkorchid4",          "darkred",              
"darksalmon",           "darkseagreen",         "darkseagreen1",        "darkseagreen2",        "darkseagreen3",        
"darkseagreen4",        "darkslateblue",        "darkslategray",        "darkslategray1",       "darkslategray2",       
"darkslategray3",       "darkslategray4",       "darkslategrey",        "darkturquoise",        "darkviolet",           
"deeppink",             "deeppink1",            "deeppink2",            "deeppink3",            "deeppink4",            
"deepskyblue",          "deepskyblue1",         "deepskyblue2",         "deepskyblue3",         "deepskyblue4",         
"dimgray",              "dimgrey",              "dodgerblue",           "dodgerblue1",          "dodgerblue2",          
"dodgerblue3",          "dodgerblue4",          "firebrick",            "firebrick1",           "firebrick2",           
"firebrick3",           "firebrick4",           "floralwhite",          "forestgreen",          "gainsboro",            
"ghostwhite",           "gold",                 "gold1",                "gold2",                "gold3",                
"gold4",                "goldenrod",            "goldenrod1",           "goldenrod2",           "goldenrod3",           
"goldenrod4",           "green",                "green1",               "green2",               "green3",               
"green4",               "greenyellow",          "honeydew",             "honeydew1",            "honeydew2",            
"honeydew3",            "honeydew4",            "hotpink",              "hotpink1",             "hotpink2",
"hotpink3",             "hotpink4",             "indianred",            "indianred1",           "indianred2",           
"indianred3",           "indianred4",           "ivory",                "ivory1",               "ivory2",               
"ivory3",               "ivory4",               "khaki",                "khaki1",               "khaki2",               
"khaki3",               "khaki4",               "lavender",             "lavenderblush",        "lavenderblush1",       
"lavenderblush2",       "lavenderblush3",       "lavenderblush4",       "lawngreen",            "lemonchiffon",         
"lemonchiffon1",        "lemonchiffon2",        "lemonchiffon3",        "lemonchiffon4",        "lightblue",            
"lightblue1",           "lightblue2",           "lightblue3",           "lightblue4",           "lightcoral",           
"lightcyan",            "lightcyan1",           "lightcyan2",           "lightcyan3",           "lightcyan4",           
"lightgoldenrod",       "lightgoldenrod1",      "lightgoldenrod2",      "lightgoldenrod3",      "lightgoldenrod4",      
"lightgoldenrodyellow", "lightgray",            "lightgreen",           "lightgrey",            "lightpink",            
"lightpink1",           "lightpink2",           "lightpink3",           "lightpink4",           "lightsalmon",          
"lightsalmon1",         "lightsalmon2",         "lightsalmon3",         "lightsalmon4",         "lightseagreen",        
"lightskyblue",         "lightskyblue1",        "lightskyblue2",        "lightskyblue3",        "lightskyblue4",        
"lightslateblue",       "lightslategray",       "lightslategrey",       "lightsteelblue",       "lightsteelblue1",      
"lightsteelblue2",      "lightsteelblue3",      "lightsteelblue4",      "lightyellow",          "lightyellow1",         
"lightyellow2",         "lightyellow3",         "lightyellow4",         "limegreen",            "linen",                
"magenta",              "magenta1",             "magenta2",             "magenta3",             "magenta4",             
"maroon",               "maroon1",              "maroon2",              "maroon3",              "mediumaquamarine",     
"mediumblue",           "mediumorchid",         "mediumorchid1",        "mediumorchid2",        "mediumorchid3",        
"mediumorchid4",        "mediumpurple",         "mediumpurple1",        "mediumpurple2",        "mediumpurple3",        
"mediumpurple4",        "mediumseagreen",       "mediumslateblue",      "mediumspringgreen",    "mediumturquoise",      
"mediumvioletred",      "midnightblue",         "mintcream",            "mistyrose",            "mistyrose1",           
"mistyrose2",           "mistyrose3",           "mistyrose4",           "moccasin",             "navajowhite",          
"navajowhite1",         "navajowhite2",         "navajowhite3",         "navajowhite4",         "navy",                 
"navyblue",             "oldlace",              "olivedrab",            "olivedrab1",           "olivedrab2",           
"olivedrab3",           "olivedrab4",           "orange",               "orange1",              "orange2",              
"orange3",              "orange4",              "orangered",            "orangered1",           "orangered2",           
"orangered3",           "orangered4",           "orchid",               "orchid1",              "orchid2",              
"orchid3",              "orchid4",              "palegoldenrod",        "palegreen",            "palegreen1",           
"palegreen2",           "palegreen3",           "palegreen4",           "paleturquoise",        "paleturquoise1",       
"paleturquoise2",       "paleturquoise3",       "paleturquoise4",       "palevioletred",        "palevioletred1",       
"palevioletred2",       "palevioletred3",       "palevioletred4",       "papayawhip",           "peachpuff",            
"peachpuff1",           "peachpuff2",           "peachpuff3",           "peachpuff4",           "peru",                 
"pink",                 "pink1",                "pink2",                "pink3",                "pink4",                
"plum",                 "plum1",                "plum2",                "plum3",                "plum4",                
"powderblue",           "purple",               "purple1",              "purple2",              "purple3",              
"purple4",              "red",                  "red1",                 "red2",                 "red3",                 
"red4",                 "rosybrown",            "rosybrown1",           "rosybrown2",           "rosybrown3",           
"rosybrown4",           "royalblue",            "royalblue1",           "royalblue2",           "royalblue3",           
"royalblue4",           "saddlebrown",          "salmon",               "salmon1",              "salmon2",              
"salmon3",              "salmon4",              "sandybrown",           "seagreen",             "seagreen1",            
"seagreen2",            "seagreen3",            "seagreen4",            "seashell",             "seashell1",            
"seashell2",            "seashell3",            "seashell4",            "sienna",               "sienna1",              
"sienna2",              "sienna3",              "sienna4",              "skyblue",              "skyblue1",             
"skyblue2",             "skyblue3",             "skyblue4",             "slateblue",            "slateblue1",           
"slateblue2",           "slateblue3",           "slateblue4",           "slategray",            "slategray1",           
"slategray2",           "slategray3",           "slategray4",           "slategrey",            "snow",                 
"snow1",                "snow2",                "snow3",                "snow4",                "springgreen",          
"springgreen1",         "springgreen2",         "springgreen3",         "springgreen4",         "steelblue",            
"steelblue1",           "steelblue2",           "steelblue3",           "steelblue4",           "tan",                  
"tan1",                 "tan2",                 "tan3",                 "tan4",                 "thistle",              
"thistle1",             "thistle2",             "thistle3",             "thistle4",             "tomato",               
"tomato1",              "tomato2",              "tomato3",              "tomato4",              "turquoise",            
"turquoise1",           "turquoise2",           "turquoise3",           "turquoise4",           "violet",               
"violetred",            "violetred1",           "violetred2",           "violetred3",           "violetred4",           
"wheat",                "wheat1",               "wheat2",               "wheat3",               "wheat4",               
"whitesmoke",           "yellow",               "yellow1",              "yellow2",              "yellow3",              
"yellow4",              "yellowgreen",          
"gray",                 "gray0",                "gray1",                "gray2",                
"gray3",                "gray4",                "gray5",                "gray6",                "gray7",                
"gray8",                "gray9",                "gray10",               "gray11",               "gray12",               
"gray13",               "gray14",               "gray15",               "gray16",               "gray17",               
"gray18",               "gray19",               "gray20",               "gray21",               "gray22",               
"gray23",               "gray24",               "gray25",               "gray26",               "gray27",               
"gray28",               "gray29",               "gray30",               "gray31",               "gray32",               
"gray33",               "gray34",               "gray35",               "gray36",               "gray37",               
"gray38",               "gray39",               "gray40",               "gray41",               "gray42",               
"gray43",               "gray44",               "gray45",               "gray46",               "gray47",               
"gray48",               "gray49",               "gray50",               "gray51",               "gray52",               
"gray53",               "gray54",               "gray55",               "gray56",               "gray57",               
"gray58",               "gray59",               "gray60",               "gray61",               "gray62",               
"gray63",               "gray64",               "gray65",               "gray66",               "gray67",               
"gray68",               "gray69",               "gray70",               "gray71",               "gray72",               
"gray73",               "gray74",               "gray75",               "gray76",               "gray77",               
"gray78",               "gray79",               "gray80",               "gray81",               "gray82",               
"gray83",               "gray84",               "gray85",               "gray86",               "gray87",               
"gray88",               "gray89",               "gray90",               "gray91",               "gray92",               
"gray93",               "gray94",               "gray95",               "gray96",               "gray97",               
"gray98",               "gray99",               "gray100")
rm(allcolors)}

showcolors <- function(generic_color = "blue") {
  ## tiling of different colors based on the common part of the name, all blue and blue adjacent colors 
  ## 
  chosen_colors <- colors()[grep(generic_color, x = colors())]
  df <- data.frame(
    x = 1:length(chosen_colors),
    color = chosen_colors
  )
  
  # Visualize colors
  ggplotly(
    ggplot(df, aes(x = x, y = 1, fill = chosen_colors)) +
      geom_tile() +
      scale_fill_identity() +
      theme(legend.position = "none")+
      theme_void()
  ) %>% layout(
    xaxis = list(autorange = TRUE),  # Autoscale x-axis
    yaxis = list(autorange = TRUE)   # Autoscale y-axis
  )
}


if (!knitr::is_latex_output() || !knitr::is_html_output()) {
  # Code that runs only during rendering
  library(rsthemes)
  set_theme_light("Xcode")
  set_theme_dark("Oceanic Plus {rsthemes}")
  use_theme_auto(lat = 45.4654, lon = 9.1865) 
}



